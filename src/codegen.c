#include <codegen.h>
#include <reg.h>
#include <symbol.h>
#include <stdlib.h>
#include <unistd.h>
#include <symbol.h>
#include <parser.h>

#define DEBUG 0


FILE* g_outfile = NULL;

static void prologue(void) {
  fputs(
      ";; Generated by the TauLang compiler.\n"
      ";; Copyright (c) 2022 Ian Marco Moffett, The IgnisOS team\n"
      ";; Licensed under the MIT license\n"
      ";; See LICENSE at https://github.com/Ian-Marco-Moffett/TauLang\n\n"
      "bits 64\n\n",
  g_outfile);
}


static void insert(const char* _asm) {
  fputs("\t;; User made ASM begin\n", g_outfile);
  fputs(_asm, g_outfile);
  fputs("\n\t;; User made ASM end\n", g_outfile);
}

/*
 *  Calls a function and returns the
 *  register with the result of the call.
 */

static size_t call(size_t slot) {
  REG r = alloc_reg();
  fprintf(g_outfile, "\tcall f__%s\n", g_symtbl[slot].name);
  fprintf(g_outfile, "\tmov %s, rax\n", rregs[r]);
  return r;
}


static void ret(REG r) {
  switch (g_symtbl[get_cur_function()].ptype) {
    case P_U8:
      fprintf(g_outfile, "\tmovzx rax, %s\n", bregs[r]);
      break;
  }
}


void func_prologue(const char* name) {
  fprintf(g_outfile,
    "f__%s:\n"
    "\tpush rbp\n"
    "\tmov rbp, rsp\n", name);
}


void global(const char* name, SYM_STYPE stype) { 
  const char* stype_prefix = "u__";

  switch (stype) {
    case S_FUNCTION:
      stype_prefix = "f__";
      break;
  }

  fprintf(g_outfile, "global %s%s\n", stype_prefix, name);
}


void func_epilouge(void) {
  fputs("\tleave\n\tretq\n\n", g_outfile);
}


int16_t gen_code(struct ast_node* r) {
  REG leftreg, rightreg;

  switch (r->op) {
    case A_FUNC:
      if (g_symtbl[r->id].is_global)
        global(g_symtbl[r->id].name, S_FUNCTION);

      func_prologue(g_symtbl[r->id].name);
      if (r->left)
        gen_code(r->left);
      func_epilouge();
      return -1;
    case A_GLUE:
      gen_code(r->left);
      freeall_regs();
      gen_code(r->right);
      freeall_regs();
      return -1;
    case A_INLINE_ASM:
      if (r->text) {
        insert(r->text);
        free((char*)r->text);
        r->text = NULL;
      }
      return -1; 
  }

  if (r->left)
    leftreg = gen_code(r->left);

  if (r->right)
    rightreg = gen_code(r->right);

  switch (r->op) {
    case A_ADD:
      return reg_add(leftreg, rightreg);
    case A_SUB:
      return reg_sub(leftreg, rightreg);
      break;
    case A_MUL:
      return reg_mul(leftreg, rightreg);
    case A_DIV:
      return reg_div(leftreg, rightreg);
    case A_INTLIT:
      return reg_load(r->val_int);
    case A_FUNCCALL:
      return call(r->id);
    case A_RETURN:
      ret(leftreg);
      return -1;
  }

  return 0;
}

void codegen_init(void) {
  g_outfile = fopen("/tmp/tauout.asm", "w");
  prologue();
}


void codegen_end(void) {
  fclose(g_outfile);
  char buf[450];
  snprintf(buf, sizeof(buf), "nasm -felf64 /tmp/tauout.asm -o /tmp/tauout.o && ld /tmp/tauout.o /lib/taulang/crt0.o -o a.out");
  system(buf);

#if !DEBUG
  remove("/tmp/tauout.asm");
#endif
  remove("/tmp/tauout.o");
}
