#include <codegen.h>
#include <reg.h>
#include <symbol.h>
#include <stdlib.h>
#include <unistd.h>
#include <symbol.h>
#include <parser.h>

#define DEBUG 1


FILE* g_outfile = NULL;

static void prologue(void) {
  fputs(
      ";; Generated by the TauLang compiler.\n"
      ";; Copyright (c) 2022 Ian Marco Moffett, The IgnisOS team\n"
      ";; Licensed under the MIT license\n"
      ";; See LICENSE at https://github.com/Ian-Marco-Moffett/TauLang\n\n"
      "bits 64\n\n",
  g_outfile);
}


static void insert(const char* _asm) {
  fputs("\t;; User made ASM begin\n", g_outfile);
  fputs(_asm, g_outfile);
  fputs("\n\t;; User made ASM end\n", g_outfile);
}

/*
 *  Calls a function and returns the
 *  register with the result of the call.
 */

static size_t call(size_t slot) {
  REG r = alloc_reg();
  fprintf(g_outfile, "\tcall f__%s\n", g_symtbl[slot].name);
  fprintf(g_outfile, "\tmov %s, rax\n", rregs[r]);
  return r;
}


static void ret(REG r) {
  switch (g_symtbl[get_cur_function()].ptype) {
    case P_U8:
      fprintf(g_outfile, "\tmovzx rax, %s\n", bregs[r]);
      break;
  }
}


static void arg(struct symbol* arg, size_t arg_number) {
  switch (arg->ptype) {
    case P_U8:
      if (arg_number == 0) {
        fprintf(g_outfile, "\tmov [rbp+16], dil\n");
      } else if (arg_number == 1) {
        fprintf(g_outfile, "\tmov [rbp+24], sil\n");
      } else if (arg_number == 2) {
        fprintf(g_outfile, "\tmov [rbp+32], dl\n");
      } else if (arg_number == 3) {
        fprintf(g_outfile, "\tmov [rbp+40], cl\n");
      } else if (arg_number == 4) {
        fprintf(g_outfile, "\tmov [rbp+48], r8b\n");
      } else if (arg_number == 5) {
        fprintf(g_outfile, "\tmov [rbp+56], r9b\n");
      } 
      break;
  }
}

static void arg_pass(REG r, size_t arg_number) {
  if (arg_number == 0) {
    fprintf(g_outfile, "\tmov rdi, %s\n", rregs[r]);
  } else if (arg_number == 1) {
    fprintf(g_outfile, "\tmov rsi, %s\n", rregs[r]);
  } else if (arg_number == 2) {
    fprintf(g_outfile, "\tmov rdx, %s\n", rregs[r]);
  } else if (arg_number == 3) {
    fprintf(g_outfile, "\tmov rcx, %s\n", rregs[r]);
  } else if (arg_number == 4) {
    fprintf(g_outfile, "\tmov r8, %s\n", rregs[r]);
  } else if (arg_number == 5) {
    fprintf(g_outfile, "\tmov r9, %s\n", rregs[r]);
  }
  
  freeall_regs();
}


/*
 *  Allocates space on the stack
 *  for local variables and arguments.
 *
 */

static inline void stack_alloc(struct symbol func) {
  if (func.rbp_offset != 0)
    fprintf(g_outfile, "\tsub rsp, %d\n", func.rbp_offset);
}


void func_prologue(const char* name) {
  fprintf(g_outfile,
    "f__%s:\n"
    "\tpush rbp\n"
    "\tmov rbp, rsp\n", name);
}


void global(const char* name, SYM_STYPE stype) { 
  const char* stype_prefix = "u__";

  switch (stype) {
    case S_FUNCTION:
      stype_prefix = "f__";
      break;
  }

  fprintf(g_outfile, "global %s%s\n", stype_prefix, name);
}


void func_epilouge(void) {
  fputs("\tleave\n\tretq\n\n", g_outfile);
}


int16_t gen_code(struct ast_node* r, struct ast_node* r1) {
  REG leftreg, rightreg;

  switch (r->op) {
    case A_FUNC:
      /*
       *  Make this symbol global
       *  if it is marked as global.
       * 
       */
      if (g_symtbl[r->id].is_global)
        global(g_symtbl[r->id].name, S_FUNCTION);

      func_prologue(g_symtbl[r->id].name);

      stack_alloc(g_symtbl[r->id]);

      // Actual code within the function.
      if (r->left)
        gen_code(r->left, NULL);
  
      // Arguments.
      if (r->right)
        gen_code(r->right, r);

      func_epilouge();
      return -1;
    case A_GLUE:
      gen_code(r->left, NULL);
      freeall_regs();
      gen_code(r->right, NULL);
      freeall_regs();
      return -1;
    case A_INLINE_ASM:
      if (r->text) {
        insert(r->text);
        free((char*)r->text);
        r->text = NULL;
      }
      return -1; 
    case A_ARG:
      /*
       *  NOTE: The extra argument field in the AST
       *        is used for the arg count when parsing
       *        function arguments.
       *
       */
      arg(&g_symtbl[r1->id].local_symtbl[r->id], r->extra_argument);

      if (r->left)
        gen_code(r->left, r1);
        
      return -1; 
    case A_ARG_PASS:
      if (r->left) {
        gen_code(r->left, NULL);
      }
      
      if (r->mid) {
        leftreg = gen_code(r->mid, NULL);
        arg_pass(leftreg, r->val_int);
      }
      return -1;
  }

  if (r->left)
    leftreg = gen_code(r->left, NULL);

  if (r->right)
    rightreg = gen_code(r->right, NULL);

  switch (r->op) {
    case A_ADD:
      return reg_add(leftreg, rightreg);
    case A_SUB:
      return reg_sub(leftreg, rightreg);
      break;
    case A_MUL:
      return reg_mul(leftreg, rightreg);
    case A_DIV:
      return reg_div(leftreg, rightreg);
    case A_INTLIT:
      return reg_load(r->val_int); 
    case A_FUNCCALL:
      return call(r->id);
    case A_RETURN:
      ret(leftreg);
      return -1;
  }

  return 0;
}

void codegen_init(void) {
  g_outfile = fopen("/tmp/tauout.asm", "w");
  prologue();
}


void codegen_end(void) {
  fclose(g_outfile);
  char buf[450];
  snprintf(buf, sizeof(buf), "nasm -felf64 /tmp/tauout.asm -o /tmp/tauout.o && ld /tmp/tauout.o /lib/taulang/crt0.o -o a.out");
  system(buf);

#if !DEBUG
  remove("/tmp/tauout.asm");
#endif
  remove("/tmp/tauout.o");
}
